// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  buyer
  seller
  admin
}

enum PackageTier {
  basic
  standard
  premium
}

enum OrderStatus {
  draft
  awaiting_payment
  in_escrow
  in_progress
  delivered
  revision_requested
  completed
  cancelled
  disputed
  resolved_refund
  resolved_partial
  resolved_upheld
}

enum DeliveryStatus {
  submitted
  accepted
  revision_requested
}

enum DisputeStatus {
  open
  needs_info
  reviewing
  resolved_refund
  resolved_partial
  resolved_upheld
}

enum PayoutStatus {
  pending
  processing
  paid
  failed
}

enum QuoteStatus {
  sent
  accepted
  declined
  expired
}

model User {
  id            String   @id @default(uuid())
  role          UserRole? // Nullable to allow PrismaAdapter to create users, set in signIn callback
  email         String   @unique
  name          String?
  avatarUrl     String?
  bio           String?
  headline      String?
  location      String?
  languages     Json     // Array of language strings (SQLite: stored as JSON)
  emailVerified DateTime? // Required by Auth.js for email verification
  isVerified    Boolean  @default(false)
  isSuspended   Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  reputation    Reputation?
  services      Service[]
  ordersAsBuyer Order[]  @relation("OrdersAsBuyer")
  ordersAsSeller Order[] @relation("OrdersAsSeller")
  payouts       Payout[]
  quotesAsBuyer Quote[]  @relation("QuotesAsBuyer")
  quotesAsSeller Quote[] @relation("QuotesAsSeller")
  reviewsAuthored Review[] @relation("ReviewAuthor")
  reviewsReceived Review[] @relation("ReviewTarget")
  messageThreads MessageThreadParticipant[]
  messagesSent Message[]
  disputesOpened Dispute[] @relation("DisputeOpener")
  disputesAssigned Dispute[] @relation("DisputeAdmin")
  accounts Account[]
  sessions Session[]

  @@index([email])
  @@index([role])
}

// Auth.js (NextAuth.js) required models
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Reputation {
  userId      String  @id
  ratingAvg   Float   @default(0)
  ratingCount Int     @default(0)
  badges      Json     // Array of badge strings (SQLite: stored as JSON)
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([ratingAvg])
}

model Service {
  id          String   @id @default(uuid())
  sellerId    String
  seller      User     @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  title       String
  slug        String   @unique
  description String   @db.Text
  category    String
  tags        Json     // Array of tag strings (SQLite: stored as JSON)
  gallery     Json     // Array of image/video URLs (SQLite: stored as JSON)
  coverImage  String?
  basePrice   Int?     // Price in minor units (cents), optional if only packages exist
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  packages    Package[]
  orders      Order[]
  quotes      Quote[]

  @@index([sellerId])
  @@index([category])
  @@index([isActive])
  @@index([slug])
  // Note: SQLite doesn't support full-text search indexes
  // Use external search index or FTS5 extension if needed
}

model Package {
  id           String   @id @default(uuid())
  serviceId    String
  service      Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  tier         PackageTier
  priceMinor   Int      // Price in minor units (cents)
  deliveryDays Int
  revisions    Int      @default(0)
  features     Json     // Array of feature strings (SQLite: stored as JSON)
  addons       Json?    // Array of { id, label, amount } objects

  @@unique([serviceId, tier])
  @@index([serviceId])
}

model Quote {
  id          String   @id @default(uuid())
  serviceId   String
  service     Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  sellerId    String
  seller      User     @relation("QuotesAsSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  buyerId     String
  buyer       User     @relation("QuotesAsBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
  lineItems   Json     // Array of { label, amount } objects
  totalMinor  Int      // Total in minor units (cents)
  currency    String   @default("USD")
  status      QuoteStatus @default(sent)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([serviceId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
}

model Order {
  id           String   @id @default(uuid())
  buyerId      String
  buyer        User     @relation("OrdersAsBuyer", fields: [buyerId], references: [id], onDelete: Restrict)
  sellerId     String
  seller       User     @relation("OrdersAsSeller", fields: [sellerId], references: [id], onDelete: Restrict)
  serviceId    String
  service      Service  @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  packageTier  PackageTier
  status       OrderStatus @default(awaiting_payment)
  amountMinor  Int      // Total amount in minor units (cents)
  currency     String   @default("USD")
  requirements Json?    // Structured Q&A object
  attachments  Json?    // Array of file URLs (SQLite: stored as JSON)
  milestones   Json?    // Array of { label, dueAt, amount, status } objects
  escrowId     String?
  paidAt       DateTime?
  deliveredAt DateTime?
  completedAt DateTime?
  cancelledAt DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  deliveries   Delivery[]
  review       Review?
  dispute      Dispute?

  @@index([buyerId, status])
  @@index([sellerId, status])
  @@index([serviceId])
  @@index([status])
  @@index([createdAt])
}

model Delivery {
  id        String   @id @default(uuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  message   String?  @db.Text
  files     Json     // Array of file URLs (SQLite: stored as JSON)
  deliveredAt DateTime?  // When delivery was submitted/accepted
  status    DeliveryStatus @default(submitted)
  createdAt DateTime @default(now())

  @@index([orderId])
  @@index([status])
}

model Review {
  id           String   @id @default(uuid())
  orderId      String   @unique
  order        Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  authorId     String
  author       User     @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  targetUserId String
  target       User     @relation("ReviewTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  rating       Int      // 1-5
  body         String?  @db.Text
  isEdited     Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([targetUserId])
  @@index([rating])
  @@index([createdAt])
}

model MessageThread {
  id            String   @id @default(uuid())
  orderId       String?  // Optional - only set for post-purchase threads
  participants  MessageThreadParticipant[]
  lastMessageAt DateTime?
  messages      Message[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([orderId])
  @@index([lastMessageAt])
}

model MessageThreadParticipant {
  id        String   @id @default(uuid())
  threadId  String
  thread    MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  joinedAt  DateTime @default(now())

  @@unique([threadId, userId])
  @@index([userId])
}

model Message {
  id        String   @id @default(uuid())
  threadId  String
  thread    MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  senderId  String
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  body      String?  @db.Text
  attachments Json?  // Array of file URLs (SQLite: stored as JSON)
  redacted  Boolean  @default(false)
  readBy    Json     // Array of user IDs who have read this message (SQLite: stored as JSON)
  createdAt DateTime @default(now())

  @@index([threadId, createdAt])
  @@index([senderId])
}

model Dispute {
  id              String   @id @default(uuid())
  orderId         String   @unique
  order            Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  openedById      String
  opener           User     @relation("DisputeOpener", fields: [openedById], references: [id], onDelete: Restrict)
  assignedAdminId String?
  assignee         User?    @relation("DisputeAdmin", fields: [assignedAdminId], references: [id], onDelete: SetNull)
  reason           String
  notes            String?  @db.Text
  status           DisputeStatus @default(open)
  resolution       Json?    // { type, amount?, notes, resolvedBy, resolvedAt }
  events           Json?    // Array of { actorId, action, notes, timestamp } objects
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([status])
  @@index([assignedAdminId])
  @@index([openedById])
}

model Payout {
  id         String   @id @default(uuid())
  sellerId   String
  seller     User     @relation(fields: [sellerId], references: [id], onDelete: Restrict)
  amountMinor Int     // Amount in minor units (cents)
  currency   String   @default("USD")
  status     PayoutStatus @default(pending)
  providerRef String?  // External payment provider reference
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([sellerId])
  @@index([status])
  @@index([createdAt])
}
